---
sidebar_position: 4
---

# Extensions
When you feel like you're repeating yourself too much or just want to have standard ways to change the value of a
**superstate**, then it's time for extensions!

Let's suppose you have a `count` superstate:

```typescript
const count = superstate(0)
```

Overriding the value of `count` is very straightforward:

```typescript
count.set(1)
```

Increasing the value of it is very straightforward as well:

```typescript
count.set(prev => prev + 1)
```

But wouldn't it be magical if you could do the following?:

```typescript
count.sum(1)
```

The example above has a few benefits:

- It's easier to read,
- It's easier to write,
- It's easier to test,
- It's easier to maintain,
- It's less verbose,
- Separates business logic from the implementation.

## Creating an extension

From the example above, to create an extension that sums your `count`:

```typescript
const count = superstate(0).extend({
  sum({ publish }, amount: number) {
    publish(prev => prev + amount)
  }
})

count.sum(1) // `count.now()` will log 1
count.sum(1) // `count.now()` will log 2
count.sum(5) // `count.now()` will log 7
```

Let's understand what's happening here:

```typescript
sum({ publish }, amount: number) {
  publish(prev => prev + amount)
}
```

> `sum`

is the name of your extension.

> `{ publish }`

is an object **superstate** gives us with helpful properties to interact with the extension and with the state itself. `publish` is one of them.

:::danger Caution
The first parameter of an extension should always be reserved to this object **superstate** passes to it.
:::

> `amount: number`

a custom, accepted parameter by the `.sum()` function. This is completely up to us to define and we can have as many parameters
as we like.

:::info
The "`: number`" piece is TypeScript. You can omit it when writing vanilla JavaScript.
:::

> `publish(prev => prev + amount)`

The same `.publish()` function as if you'd call `count.publish(10)`.


## Computed values

Given the example below,

```typescript
const user = superstate({ firstName: 'John', lastName: 'Doe' })
```

It's exhaustive to always be concatenating the first and last name of the user:

```typescript
// logs John Doe
console.log(`${user.now().firstName} ${user.now().lastName}`)
```

Extensions got you covered by allowing computed values. Let's see how it works:

```typescript
const user =
  superstate({ firstName: 'John', lastName: 'Doe' })
    .extend({ fullName })

function fullName({ draft, now }) {
  // Prioritizes the `draft`'s' version of the user;
  // If it doesn't exist, let's use the `now`'s version.
  const _user = draft ?? now

  return `${_user.firstName} ${_user.lastName}`
}

console.log(user.fullName()) // logs John Doe
```

Just to give you another use-case for computed values:

```typescript
const money = superstate(100).extend({ formatted })

function formatted({ now, draft }) {
  return `$${draft || now}`
}

console.log(money.formatted()) // logs $100
```


## Side effects

You can also handle side effects within your extension's scope:

```typescript
const count = superstate(0).extend({
  sum({ publish, draft, now }, amount: number) {
    const next = amount + (draft ?? now)
    publish(next)

    // Feel free to do whatever you like.
    alert(`count has changed to ${next}.`)
  }
})
```

Note that by doing the above, whenever you call `.sum()`, the `alert()` will be called as well&mdash;meaning you are the one in charge
for managing your side effect(s) lifecycle.
